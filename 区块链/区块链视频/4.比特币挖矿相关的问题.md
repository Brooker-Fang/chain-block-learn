## 比特币挖矿相关问题

### 比特币节点
+ 运行区块链软件的计算机就是一个节点
  + 每个比特币钱包都是一个节点
+ 全节点
  + 拥有完整区块链账本的节点叫做全节点，赋值比特币转账交易的广播和验证
  + 同步整个区块链并对交易做验证，同时中继区块在网络上的传播
+ 轻节点
  + 不挖矿，只进行比特币交易的普通节点
+ 挖矿节点
  + 带挖矿功能的全节点
  + 转账交易发生后由所有节点共同广播至全网，挖矿节点验证该交易正确后会记录至区块链账本
  + 挖矿节点一般就是记账节点
+ 因为不需要安装全节点也可以进行比特币转账，所以比特币全节点个数只占全部节点数的一小部分。

### 挖矿、矿工、矿机、矿场、矿池
+ 挖矿是在争取记账权，将一段时间内比特币系统中发生的交易进行确认，并且记录在区块链上的过程
  + 挖矿就是矿工之间比拼算了，拥有较大算力的矿工挖到比特币的概率更大
  + 挖矿需要矿机、比特币地址、挖矿软件
  + 比特币挖矿软件，分配好每台矿机的任务就可以挖矿了
  + 每种代币的算法不同，所需的矿机各不相同
+ 矿工：从事虚拟货币挖掘的人就是比特币矿工
  + 矿工的主要工作是交易确认和数据打包
  + 实际挖矿不需要矿工实际动手，由电脑执行特定运算，只有保证电力供应和网络连接就可以了
+ 矿机：矿机就是通过大量计算来争夺记账权的专业设备，通过争夺记账权获得比特币奖励
  + 矿机由挖矿芯片、散热片、风扇组成
  + 只执行单一的计算程序，耗电量很大
+ 矿场：矿机集中起来形成矿场和矿池，矿场只负责计算
+ 矿池：参与挖矿的人数越来越多，全网算力上涨，挖矿难度持续上涨，单个设备或少量算力都是很难在挖到比特币，这时矿池诞生了，很多矿工加入矿池一起挖矿
  + 矿池突破抵赖位置限制，将分布在全球的矿工及矿场的算力连接到一起挖矿
  + 矿池赋值信息打包，接入到矿池的矿场负责计算，竞争记账权
  + 挖到比特币后，矿池根据矿场的算力占比分配收益，以此保证更稳定的投入产出
  + 矿池算力越大，挖到比特币的概率就更高
+ 算力
+ 哈希算法
+ 难度、难度目标、难度重定
  + 难度Difficulty
    + 整个网络会通过调整 “难度” 这个变量来控制生成工作量证明所需要的算力
    + 随着难度增加，矿工通常在循环遍历4亿次随机数值仍未找到区块，则会启用超额随机数
  + 难度目标Bits：
    + 使整个网络的计算力大致每10分钟产生一个区块所需要的难度数值即为难度目标
    + Bits是用来存储难度目标的16进制数值，Bits值越小，难度越大，越难挖矿
  + 难度重定：
    + 每新增2016个区块，全网难度将重新计算，该新难度值将已经前2016个区块的好像算力而定
    + 按每10分钟产生一个区块的速度计算，每产生2016区块大约需要14天

## 区块结构
+ 区块包括区块头、区块体
+ 区块体记载了交易详情、交易计数器、区块大小
+ 区块头：是每个区块的前80个字节，包含6部分信息
  + Version版本号，4个字节
  + 前一个区块的hash，32个字节
  + 本情况所有交易的默克尔根，32个字节
  + 时间戳，4个字节
    + 比特币是P2P网络，没有中心服务器，每个节点的时间戳有可能不一样。因此比特币系统规定：
      + 新区块时间戳要大于前11个区块平均时间戳
      + 不超过当前网络时间2小时
      + 所以后一个区块时间戳比前一个区块的时间戳反而下也是有可能的
  + 难度目标Bits，4个字节
  + 随机数Nonce，4个字节
    + Nonce是全网矿工计算当前区块hash值的核心参数

## 默克尔树 和 默克尔根
+ Merkle Tree，通常也被称作Hash Tree，就是存储hash值的一棵树
+ 每条交易信息都具有hash值，将所有交易按照手续费高低排序，第一交易是挖矿所得的coinbase交易
+ 挖矿系统将该区块能容纳下的所有交易信息打包，两两hash，如果出现奇数，则赋值自身然后hash
+ Coinbase交易是每个区块中的第一个交易，该交易是由矿工创建的，交易内容是系统奖励给矿工的比特币
+ 生成一颗完整的Merkle树需要递归地对哈希节点对 进行哈希
+ 区块链的区块头必须包含区块中所有交易哈希计算得到的有效默克尔根，而该值也是挖矿非常重要的参数

## 挖矿原理
+ 挖矿的过程就是重复计算区块头的hash，不断修改随机数Nonce，直到小于难度目标Bits计算出来的hash